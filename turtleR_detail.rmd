---
title: "Turtle技术细节"
author: "Sida.Li"
date: "June 1, 2017"
output: html_document
---
##数据输入

根据下面的内容随时更新

* 回测日期
* 产品名单
* Account (账户起始资金)
* Shadow_Account(一开始等于Account)
* Frequency (取数据的频率)
* Slippage(滑点)
* vm      (合约倍数)
* free.rate(手续费)
* System.Selection(选择System1还是System2来交易，暂定 = System2，因为比较好做)
* position (开始时为一个 1xk 的0向量，k是回测的资产数)
* relationship_matricies(= list(), 里面存着2个矩阵，表明三个资产之间的强关系，弱关系，)


##数据读取

**技术细节**
**输入文件：基础数据或者数据库，以及上述参数**

0. **重要！核心参数处理要在这一块做完，否则形成总表之后会很头疼！**
1. 建立一个初始数据模块，所有初始数据都应该在这里设置，不要单独在其他地方搞。
2. 读取指定路径下的数据库/自行下载数据。
3. 读取数据以list的形式分别储存，（沿用SNR的方法）最初的版本，建议用3个不同资产组合起来看看会出现什么问题。 
4. 合并生成的结果是总表 data_dt (初步决定为t行（k+j)*5列的表，t是时间周期，k是资产数量，j是需要额外添加的参数数量)，应该是可以使用by或者join的data.table的特性，可以尝试着删除一些数据来测试会不会出BUG


###计算每个产品需要的数据

1. 这里可能涉及到缺失值的清洗，切记如果需要填补缺失值，要使用有效率的算法。
2. 如上文所述，这一部分应该是包裹在数据下载/处理阶段的，要单独建立一个运算指标的模块。
3. 另外，这个部分直接算Unit是不现实的，（由于Account会根据交易情况调整，Unit本身是一个随着时间浮动的数值）建议先做N*Dollars Per Point，即一个包含N变化的数列乘以product里面一手合约数量的常数。

4. 还需要加入的是10天，20天均线，以便获利了结。

5. 最后形成的结果就是数据处理的那张data_dt。

**输出文件：一个包含计算好的原始数据的data（list) 以及 data_dt(data.table)**

##主循环Main Loop

请注意创建System1和System2两个分支

###资金管理

**技术细节**
**输入文件：1.data_dt;**

1. 根据ptr来扫copy之后的cdt，然后进行运算。
2. 由于Turtle本身有system1 & system2，下面的每个环节都会涉及到判定的问题，或者我们应该在Mainloop的开头就做好这个判定。
（每个loop都必须清晰的在“}”处标记出来属于哪个结尾。
3. 资金管理限制：在这里要判定现有资金是否为初始资金的90%或者更低，要设计一个shadow_account，所有Unit的计算
都需要通过$\frac{ShadowAccount*1\%}{N*DollarsPerPoint}$来运算.shadow_account的初始值为Account，当资金现值小于$90\%*shadow_account$时，$shadow_account = 80\%*shadow_account$,且当资金现值大于Account时，Shadow_Account = Account。

4. 这一步主要的产出是Shadow_Account,后面的检查和开仓都要用到，在使用了其他资金管制规则的情况下，这部分可能被删除或者更改。

**输出文件：1.Shadow_Account(更改）**

###**持仓限定-重要风控手段、运算黑洞（开始looping）**

**输入文件：cdt,Shadow_Account,position，relationship_matricies[[1:2]]**

1. 理论上来说，如果下面开仓判定做的好，这一部分只是一个“双保险”的作用，实际上应该有一个储存现有持仓的矩阵（或list?），假设有三个资产，在任意一个时间点持仓状况的对应行应该是[3,-2,0]或者[-1,1,1]这样显示了每个持仓的Unit数量的向量，那么其乘以一个相关矩阵，比如说“Closely Correlated Markets Matrix"，应该是判定每个资产之间的关系。这里会发现规则是按照产品来检查，而不是按照每一个关系组来检查的，也就是说在这个案例下所有产品的最大值都不能超过6.

```{r echo=FALSE}
matrix(c(1,1,0,0,1,0,0,0,1),3,3)

c(1,1,0) %*% matrix(c(1,1,0,0,1,0,0,0,1),3,3)
```

当然，由于产品的关系往往是相互的，比如上例的产品1和产品2，出来的数列里面第一个数字和第二个数字一定相等，会造成一些冗余，不过没关系，在“any”的函数下并不影响判定，最多不过一次过跳好多个超编产品罢了。

同样的判定还会出现在下面的进场环节，比如说同时有多个交易信号触发了，得根据信号的强弱排列出交易顺序，然后每次交易还得判断上述的4个矩阵，如果爆了就中止加仓。

这一段可以作为下面判定loop的预演
**输出数据：判定列1(判断单个资产，所有数字都要在$\pm4$内)；判定列2（所有符合强相关资产集合的数列，每个数字都在$\pm6$内）；判定列3（所有符合强相关的资产投资数字在$\pm10$内；判定列4(position数列加总在$\pm12$内**

判定列全部为1后可以进入到loop下一环，否则报错error()

###**进场**

**使用数据： 1.cdt;2.Shadow_Account；3.system.selection**


**技术细节**

进场算法涉及到许多规则和细节，处理起来也相当的复杂，就在段落开头先写。简单来说要满足下面几个功能：

1. 先判定走哪套系统（一开始可以先写system2)
2. 记录开仓信号，以及该信号是否成功信号（后面要拿来判定是否开仓）
3. 判定开仓条件（比如通道突破），判定上一个开仓信号成功/失败，形成一个k个元素的向量。
4. 将开仓信号进行强弱排序。
5. 根据开仓信号从最强的开始加仓，每次加仓还需要判定持仓限定的四个条件有没有打爆，打爆则直接停止。
6. 单日内如果出现较大涨幅，还需要能完成迅速加仓（加仓的时候还需要判定持仓限制）
7. 要将每笔交易记录存入到trading_record里面，后面还需要调用，可以考虑每个loop设计两个交易记录存档，完成进场之后先将交易记录存到一个中转站standing_record，然后将中转站的数据记录到trading_record（使用append)。当需要进行离场、平仓操作的时候，再讲standing_record里面的对应产品数据subset下来，处理完之后将该记录从standing_record删除，以备下次使用。
8. 每笔记录还要能够更新止损位，比如连买4笔则需要将整体的止损都提升到最后一笔的交易水平，在加仓状态下，不能删除前面的trading record,以便止损的时候计算损失。

**产生数据： 1.standing_record；2.trading_record；3.position(改写）**

###**退场**




1.简单策略： 止损点保持在最新成交价的距离2N处(多仓-2N，空仓+2N)。

2.Whipsaw ： 这个方法比较复杂，要在算法上实现也是比较困难，准备在后期再补完。

        Whipsaw实际上就是将止损点截在0.5N处，但是万一形势再次逆转，可以立马开仓跟进。(交易成本会变高)

**技术细节**
**使用数据： 1.cdt;2.standing_record;3.position**
**产生数据： 1.trading_record(改写)；2.position(改写)；3.standing_record(改写)；4.Account（改写）**

（退场涉及到一个当日退场的问题，可以根据close与high/low的关系，如果close更接近low,就做当日平仓，相当于当天的多单直接被打爆了止损，其他情况下就是判定现有持仓是否触及到止损线。判定相对简单，只需要逐个产品比对前后两期的持仓数字是否相同即可处理当日退场的问题，如果close接近high，理论上应该讲仓位放到第二天再判断是否离场（close接近high就假设当天一路是低开高走）。

1. 持仓状态应该是一个k个数字的数列，乘以经过处理的止损价格数列（简单乘）就可以得到一个止损数组。另一个数组则是持仓状态*现价（去掉持仓为0的比较），两者相减小于0的部分（或者逻辑判定有小于的部分）则进入止损运算。

2. 止损运算模块要从standing_record里面提取止损点，并且计算每笔交易的亏损，然后改写
Account里面的数字以及记录到trading_record.

3. 要留一个Whipsaw的接口，输出结果要与简单止损相似。

###**了结**

了结也是分两个系统的：
1. System1用的是10天的最高/最低价(对应空仓/多仓)。
2. System2用的是20天(开仓的时候用的是55天的指标)

**技术细节**
**使用数据： 1.cdt;2.standing_record;3.position**
**产生数据： 1.trading_record(改写)；2.position(改写)；3.standing_record(改写)；4.Account（改写）**

1. 需要做一个接口，初步说来很可能一开始搭建的是system2。
2. 代码应该跟退场相似，提取到均线就可以走一套结算流程。


###**日结**

1. 更新资产表

###**结束循环**
**技术细节**
**使用数据： 1.out,trading_record**
**产生数据： 1.out_dt; 2.trading_record_dt**

将连续append的out以及trading都bind成data.table，然后就可以输出了，后续的操作就在data.table上弄。




###**数据输出以及制图**

有现成的各种回测体系可以拷贝参考，只要确保输出的outlist相似就可以了。










