sta_contract_dt <- list.stack(standing_contract, data.table = TRUE)
position = holding/units
test_3 = abs(position %*% corr_mat[[2]]) - threshold_3
} #end of test_3
#test 4
threshold_4 = 12     #单向判断，请记得改回12
position_4 <- (holding/units)
judgement = -1*(holding>=0) + 1 * (holding <0)   #这个可以用于判定计算应调整仓位时的正负方向,与持仓方向相反
test_4 = abs(sum(na.fill(position_4,0))) - threshold_4
while(max(test_4) > 0){
a_items_4 <- product_ids[(na.fill(position,0) * sum(na.fill(position,0))) >0]
a_close_4 <- sta_contract_dt[product_name %in% a_items_4,][.N,]
pick_4  =  match(a_close_4$product_name,product_ids)
holding[pick_4] = holding[pick_4] + judgement[pick_4] * a_close_4$no_contract #改合约数
#记账
trade_id    = a_close_4[, trade_id]
enter_date  = a_close_4[, enter_date]
enter_price = a_close_4[, enter_price]
leave_date  = cdt[ptr, date]
leave_price = cdt[[3 + (pick_4 - 1) * 15]][ptr] - slippage[pick_4]   #开盘就应该平掉了
ori_direction = "test4"
commision   = leave_price * vm[pick_4] + enter_price * vm[pick_4]
profit      = -judgement[pick_4] * (leave_price - enter_price) * vm[pick_4] * a_close_4$no_contract
closed_profit = closed_profit + profit
fee         = fee + leave_price * vm[pick_4] * a_close_4$no_contract * fee.rate[pick_4]
cash        = cash + judgement[pick_4] * leave_price * vm[pick_4] * a_close_4$no_contract - leave_price * vm[pick_4] * a_close_4$no_contract * fee.rate[pick_4]
trade_out_a4  <- data.table(
trade_id   = trade_id,
item       = product_ids[pick_4],
enter_date = enter_date,
enter_price = enter_price,
leave_date = leave_date,
leave_price = leave_price,
long_short = ori_direction,
commision = commision,
profit    = profit,
contracts = a_close_4[,no_contract]
)
trades <- list.append(trades, trade_out_a4)
standing_contract[[sta_contract_dt[product_name == product_ids[pick_4]][.N]$trade_id]] = NULL
sta_contract_dt <- list.stack(standing_contract, data.table = TRUE)
position = holding/units
test_4 = abs(sum(position)) - threshold_4
}#end of test 4
#####################End of Asset Monitor######################################
####################Open Position##############################################
#system2
#generate long/short signal
highs  <- vector()
lows <- vector()
highs_55 <- vector()
lows_55 <- vector()
ATRs  <- vector()
sig_long  <- vector()
sig_short <- vector()
for (j in 1:length(product_ids)){     #extract the high,55high, low,55low
highs  <- append(highs,cdt[[4+(j-1)*15]][ptr]) #vector that have high prices
highs_55 <- append(highs_55,cdt[[15+(j-1)*15]][ptr]) #vector that have the upper channel
lows <- append(lows,cdt[[5+(j-1)*15]][ptr])
lows_55 <- append(lows_55,cdt[[16+(j-1)*15]][ptr])
ATRs  <- append(ATRs,cdt[[9+(j-1)*15]][ptr]) #help to determin strength of signal
}
#Then we will need a vector to see if channels been broke
sig_long <- highs > highs_55  #These tell whether we need to long/short
sig_short <- lows < lows_55
#But we need to go one step further, how many units to long/short?
#Turtle rules add units for every 0.5 * N (ATR), so we need to make
#it clear about how many Ns are the prices exceed signals
unit_long <- floor((sig_long * highs - sig_long * highs_55)/(0.5*ATRs))  #make sure you don't include any negative number
unit_long <- unit_long  + sig_long#0.5N的情况下应该一共进2个unit，所以整体要根据sig加1或者加0
unit_long[unit_long > 4] = 4 #大于2个N不加仓
unit_short <- floor((sig_short * lows_55 - sig_short * lows)/(0.5*ATRs))
unit_short <- unit_short + sig_short
unit_short[unit_short > 4] = 4 #大于2个N不继续加空仓
enter_date = NA     #中转日期
product_name = NA     #产品类型
direction = NA      #中转合约方向
enter_price = NA    #中转入场价
cut_point = NA      #中转止损价
no_contract = NA    #中转合约数量
#1.生成交易单
#long_plan <- sig_long * units  #The aggregate plan of how many *contracts(not tons)* should be add
#建立测试仓位用的向量,相当于缓存
#
for (j in 1:length(product_ids)){
if (is.na(unit_long[j])){ next
}else if (unit_long[j] == 0) {next }  #节省运算时间,跳过没有买入计划的产品
t_position = copy(position) #在单日开多单的情况下必须重复读取实际的position，因为
t_position[is.na(t_position)] = 0
#t_position会在k-loop里面累加，影响到其他产品的测试结果
for(k in 1:unit_long[j]) {
t_position[j] = t_position[j] + 1
#test 1: any direction ,single holding should be less than 4
if (any(abs(na.exclude(t_position)) > 4)) {
#test 2: any direction, combination of strong corr assets should be less than 6
}else if (any(abs(as.vector(t_position) %*% corr_mat$clscorr) > 6)){
#test 3: any direction, combination of losely corr assets should be less than 10
}else if (any(abs(c(t_position) %*% corr_mat$lslcorr) > 10)){
#test 4: any direction, total holding should be less than 12
}else if (abs(sum(t_position)) > 12){
}else {
position[j] <- t_position[j]     #update the actual position
holding[j] <- holding[j] + units[j]   #update holdings
enter_date <- cdt[[1]][ptr]
direction <- 1L                 # 1L long, -1L short
enter_price <- cdt[[15 + (j-1) * 15]][ptr] + slippage[j]  #subset the channel price + slippage
fee <- fee + enter_price * units[j] * vm[j] * fee.rate[j]          #update total fee
cut <- enter_price - 2 * cdt[[9+(j-1)*15]][ptr]          #lost cutting point, 2N
trade_id <- paste("|",direction,"|",enter_date,cdt[[2 + (j-1) * 15]][ptr],"00",k,sep = "")
contract <- data.table(trade_id = trade_id,
enter_date = enter_date,                    #saving contract information
product_name   = cdt[[2 + (j-1) * 15]][ptr],
direction = direction,
enter_price = enter_price,
cut_point = cut,
no_contract = units[j]
)
standing_contract = list.append(standing_contract, contract)  #adding contract to current holding
cash <- cash - enter_price * units[j] * vm[j] - enter_price * units[j] * vm[j] * fee.rate[j]    #update cash
}
}#end of k looping for open tests
}#开多仓loop
enter_date = NA     #中转日期
product_name = NA     #产品类型
direction = NA      #中转合约方向
enter_price = NA    #中转入场价
cut_point = NA      #中转止损价
no_contract = NA    #中转合约数量
#1.生成交易单
#long_plan <- sig_long * units  #The aggregate plan of how many *contracts(not tons)* should be add
#建立测试仓位用的向量,相当于缓存
#
for (j in 1:length(product_ids)){
if (is.na(unit_short[j])){next}
else if (unit_short[j] == 0) next  #节省运算时间,跳过没有买入计划的产品
t_position = copy(position) #在单日开多单的情况下必须重复读取实际的position，因为
t_position[is.na(t_position)] = 0
#t_position会在k-loop里面累加，影响到其他产品的测试结果
for(k in 1:unit_short[j]) {
t_position[j] = t_position[j] - 1
#test 1: any direction ,single holding should be less than 4
if (any(abs(t_position) > 4)) {
#test 2: any direction, combination of strong corr assets should be less than 6
}else if (any(abs(t_position %*% corr_mat$clscorr) > 6)){
#test 3: any direction, combination of losely corr assets should be less than 10
}else if (any(abs(t_position %*% corr_mat$lslcorr) > 10)){
#test 4: any direction, total holding should be less than 12
}else if (abs(sum(t_position)) > 12){
}else {
position[j] <- t_position[j]     #update the actual position
holding[j] <- holding[j] - units[j]   #update holdings
enter_date <- cdt[[1]][ptr]
direction <- -1L                 # 1L long, -1L short
enter_price <- cdt[[16 + (j-1) * 15]][ptr] - slippage[j]  #subset the channel price - slippage
fee <- fee + enter_price * units[j] * vm[j] * fee.rate[j]          #update total fee
cut <- enter_price + 2 * cdt[[9+(j-1)*15]][ptr]          #lost cutting point, 2N
trade_id <- paste("|",direction,"|",enter_date,cdt[[2 + (j-1) * 15]][ptr],"00",k,sep = "")
contract <- data.table(trade_id = trade_id,
enter_date = enter_date,                    #saving contract information
product_name   = cdt[[2 + (j-1) * 15]][ptr],
direction = direction,
enter_price = enter_price,
cut_point = cut,
no_contract = units[j]
)
standing_contract = list.append(standing_contract, contract)  #adding contract to current holding
cash <- cash + enter_price * units[j] * vm[j] - enter_price * units[j] * vm[j] * fee.rate[j]   #update cash
}
}#end of k looping for open tests
}#开空仓loop
####################################数据处理##################################
names(standing_contract) = list.map(standing_contract, trade_id)     #update trade id as name
sta_contract_dt <-  list.stack(standing_contract, data.table = TRUE)   #use data.frame for easy tracking
####################End of Open Position#######################################
#####################Close Position############################################
save_sta_dt <- sta_contract_dt         #需要改回全集
temp_cdt <- cdt[ptr]                   #需要改回ptr
l_contracts <- save_sta_dt[direction == 1]  #存储多单
s_contracts <- save_sta_dt[direction == -1] #存储空单
#提取高低收矩阵
c_highs <- vector()           #存储最高价
c_lows <- vector()            #存储最低价
c_opens <- vector()           #存储开盘价
for (j in 1:length(product_ids)) {
c_highs[j] <- temp_cdt[[4 + (j-1) * 15]]
c_lows[j]  <- temp_cdt[[5 + (j-1) * 15]]
c_opens[j] <- temp_cdt[[3 + (j-1) * 15]]
}
#集成每个产品当日的相关数据
information <- data.table(product_name = product_ids,
highs = c_highs,
lows  = c_lows,
opens = c_opens
)
#集成表格以便判断是否止损。
if(nrow(l_contracts) != 0) {
l_contracts <- as.data.table(left_join(l_contracts, information, by = "product_name"))
l_close <- l_contracts[cut_point > lows,]
}else{
l_close = data.table()
}
if(nrow(s_contracts) != 0) {
s_contracts <- as.data.table(left_join(s_contracts, information, by = "product_name"))
s_close <- s_contracts[cut_point < highs,]
}else{
s_close = data.table()
}
#记录每笔交易信息-平空仓
if(nrow(s_close) == 0){
}else{
for (j in 1:nrow(s_close)){
product_match = match(s_close[j,product_name],product_ids)
trade_id    = s_close[j, trade_id]
enter_date  = s_close[j,enter_date]
enter_price = s_close[j,enter_price]
leave_date  = cdt[ptr,date]
leave_price = s_close[j,cut_point] + slippage[product_match]
ori_direction = s_close[j,direction]
commision   = leave_price * vm[product_match] + enter_price * vm[product_match]
profit      = (enter_price - leave_price) * vm[product_match] * s_close[j,no_contract]
closed_profit = closed_profit + profit
fee         = fee + leave_price * vm[product_match] * s_close[j,no_contract] * fee.rate[product_match]
cash        = cash - leave_price * vm[product_match] * s_close[j,no_contract] - leave_price * vm[product_match] * s_close[j,no_contract] * fee.rate[product_match]
position[product_match] = position[product_match] +1 #adjust position
holding[product_match] = holding[product_match] + s_close[j,no_contract] #空仓应该反加回去
trade_out  <- data.table(
trade_id   = trade_id,
item       = product_ids[product_match],
enter_date = enter_date,
enter_price = enter_price,
leave_date = leave_date,
leave_price = leave_price,
long_short = ori_direction,
commision = commision,
profit    = profit,
contracts = s_close[j,no_contract]
)
trades <- list.append(trades, trade_out)
}
# 删除standing_contract里面的数据
d_trades <- list.map(trades, trade_id)
for (l in 1:length(d_trades)){
standing_contract[d_trades[[l]]] = NULL
}
# 更新sta_contract_dt
sta_contract_dt <-  list.stack(standing_contract, data.table = TRUE)   #use data.frame for easy tracking
}#end of judging nrow == 0
#记录每笔交易信息-平多仓
if(nrow(l_close) == 0){
}else{
for (j in 1:nrow(l_close)){
product_match = match(l_close[j,product_name],product_ids)
trade_id    = l_close[j, trade_id]
enter_date  = l_close[j, enter_date]
enter_price = l_close[j, enter_price]
leave_date  = cdt[ptr, date]
leave_price = l_close[j, cut_point] - slippage[product_match]   #go against the trade
ori_direction = l_close[j, direction]
commision   = leave_price * vm[product_match] + enter_price * vm[product_match]
profit      = (leave_price - enter_price) * vm[product_match] * l_close[j,no_contract]
closed_profit = closed_profit + profit
fee         = fee + leave_price * vm[product_match] * l_close[j,no_contract] * fee.rate[product_match]
cash        = cash + leave_price * vm[product_match] * l_close[j,no_contract] - leave_price * vm[product_match] * l_close[j,no_contract] * fee.rate[product_match]
position[product_match] = position[product_match] - 1 #adjust position
holding[product_match] = holding[product_match] - l_close[j,no_contract] #空仓应该反加回去,多仓应该反减
trade_out  <- data.table(
trade_id   = trade_id,
item       = product_ids[product_match],
enter_date = enter_date,
enter_price = enter_price,
leave_date = leave_date,
leave_price = leave_price,
long_short = ori_direction,
commision = commision,
profit    = profit,
contracts = l_close[j,no_contract]
)
trades <- list.append(trades, trade_out)
}
# 删除standing_contract里面的数据
d_trades <- list.map(trades, trade_id)
for (l in 1:length(d_trades)){
standing_contract[d_trades[[l]]] = NULL
}
# 更新sta_contract_dt
sta_contract_dt <-  list.stack(standing_contract, data.table = TRUE)   #use data.frame for easy tracking
}#end of judging nrow == 0
#####################End of Close Position#####################################
#####################Exit Strategy#############################################
temp_cdt <- cdt[ptr]                   #需要改回ptr
l_contracts <- sta_contract_dt[direction == 1]  #存储多单
s_contracts <- sta_contract_dt[direction == -1] #存储空单
#读取20日高低价数据
#
#提取高低收矩阵
e_highs <- vector()           #存储最高价
e_lows <- vector()            #存储最低价
e_20highs <- vector()           #存储突破价
e_20lows <- vector()            #存储突破价
e_opens <- vector()           #存储开盘价
for (j in 1:length(product_ids)) {
e_highs[j] <- temp_cdt[[4 + (j-1) * 15]]
e_lows[j]  <- temp_cdt[[5 + (j-1) * 15]]
e_20highs[j] <- temp_cdt[[13 + (j-1) * 15]]
e_20lows[j]  <- temp_cdt[[14 + (j-1) * 15]]
e_opens[j] <- temp_cdt[[3 + (j-1) * 15]]
}
#集成每个产品当日的相关数据
information <- data.table(product_name = product_ids,
opens   = e_opens,
high    = e_highs,
low     = e_lows,
highs20 = e_20highs,
lows20  = e_20lows
)
#集成表格以便判断是否止损。
if(nrow(l_contracts) != 0) {
l_contracts <- as.data.table(left_join(l_contracts, information, by = "product_name"))
l_exit <- l_contracts[low < lows20,]
}else{
l_exit = data.table()
}
if(nrow(s_contracts) != 0) {
s_contracts <- as.data.table(left_join(s_contracts, information, by = "product_name"))
s_exit <- s_contracts[high > highs20,]
}else{
s_exit = data.table()
}
#记录每笔交易信息-平空仓
if(nrow(s_exit) == 0){
}else{
for (j in 1:nrow(s_exit)){
product_match = match(s_exit[j,product_name],product_ids)
trade_id    = s_exit[j, trade_id]
enter_date  = s_exit[j,enter_date]
enter_price = s_exit[j,enter_price]
leave_date  = cdt[ptr,date]
leave_price = s_exit[j,highs20] + slippage[product_match]
ori_direction = s_exit[j,direction]
commision   = leave_price * vm[product_match] + enter_price * vm[product_match]
profit      = (enter_price - leave_price) * vm[product_match] * s_exit[j,no_contract]
closed_profit = closed_profit + profit
fee         = fee + leave_price * vm[product_match] * s_exit[j,no_contract] * fee.rate[product_match]
cash        = cash - leave_price * vm[product_match] * s_exit[j,no_contract] - leave_price * vm[product_match] * s_exit[j,no_contract] * fee.rate[product_match]
position[product_match] = position[product_match] +1 #adjust position
holding[product_match] = holding[product_match] + s_exit[j,no_contract] #空仓应该反加回去
trade_out_e  <- data.table(
trade_id   = trade_id,
item       = product_ids[product_match],
enter_date = enter_date,
enter_price = enter_price,
leave_date = leave_date,
leave_price = leave_price,
long_short = ori_direction,
commision = commision,
profit    = profit,
contracts = s_exit[j,no_contract]
)
trades <- list.append(trades, trade_out_e)
}
# 删除standing_contract里面的数据
d_trades <- list.map(trades, trade_id)
for (l in 1:length(d_trades)){
standing_contract[d_trades[[l]]] = NULL
}
# 更新sta_contract_dt
sta_contract_dt <-  list.stack(standing_contract, data.table = TRUE)   #use data.frame for easy tracking
}#end of judging nrow == 0
#记录每笔交易信息-平多仓
if(nrow(l_exit) == 0){
}else{
for (j in 1:nrow(l_exit)){
product_match = match(l_exit[j,product_name],product_ids)
trade_id    = l_exit[j, trade_id]
enter_date  = l_exit[j, enter_date]
enter_price = l_exit[j, enter_price]
leave_date  = cdt[ptr, date]
leave_price = l_exit[j, lows20] - slippage[product_match]   #go against the trade
ori_direction = l_exit[j, direction]
commision   = leave_price * vm[product_match] + enter_price * vm[product_match]
profit      = (leave_price - enter_price) * vm[product_match] * l_exit[j,no_contract]
closed_profit = closed_profit + profit
fee         = fee + leave_price * vm[product_match] * l_exit[j,no_contract] * fee.rate[product_match]
cash        = cash + leave_price * vm[product_match] * l_exit[j,no_contract] - leave_price * vm[product_match] * l_exit[j,no_contract] * fee.rate[product_match]
position[product_match] = position[product_match] - 1 #adjust position
holding[product_match] = holding[product_match] - l_exit[j,no_contract] #空仓应该反加回去,多仓应该反减
trade_out_e  <- data.table(
trade_id   = trade_id,
item       = product_ids[product_match],
enter_date = enter_date,
enter_price = enter_price,
leave_date = leave_date,
leave_price = leave_price,
long_short = ori_direction,
commision = commision,
profit    = profit,
contracts = l_exit[j,no_contract]
)
trades <- list.append(trades, trade_out_e)
}
# 删除standing_contract里面的数据
d_trades <- list.map(trades, trade_id)
for (l in 1:length(d_trades)){
standing_contract[d_trades[[l]]] = NULL
}
# 更新sta_contract_dt
sta_contract_dt <-  list.stack(standing_contract, data.table = TRUE)   #use data.frame for easy tracking
}#end of judging nrow == 0
#####################End of Exit Strategy######################################
#####################Asset Chart Update########################################
if(nrow(sta_contract_dt) != 0){
a_cont  <- sta_contract_dt
a_close <- vector()           #存储收盘价
for (j in 1:length(product_ids)) {
a_close[j] <- cdt[[6 + (j-1) * 15]][ptr]
}
cls_status <- data.table(product_name = product_ids,
vm           = vm,
close        = a_close)
a_cont     <- as.data.table(left_join(a_cont, cls_status, by = "product_name"))
asset_out <- data.table(
date = cdt[ptr,date],
cash = cash,
fee  = fee,
holding_value = sum(holding * vm * a_close),
pos_profit = sum(a_cont$direction * (a_cont$close - a_cont$enter_price) * a_cont$no_contract * a_cont$vm),
pos_dir = sum(position),
closed_profit = closed_profit
)
asset_list <- list.append(asset_list, asset_out)
}else{
a_close <- vector()           #存储收盘价
for (j in 1:length(product_ids)) {
a_close[j] <- cdt[[6 + (j-1) * 15]][ptr]
}
asset_out <- data.table(
date = cdt[ptr,date],
cash = cash,
fee  = fee,
holding_value = sum(holding*a_close),
pos_profit = "no holding",
pos_dir = sum(position),
closed_profit = closed_profit
)
}#end of if nrow(sta_contract_dt == 0)
#####################End of Asset Chart Update#################################
}# end of main loop
######################End of Main Loop#########################################
trades_dt <- list.stack(trades, data.table = TRUE)
trades_dt[, net_profit := profit - commision]
asset_dt  <- list.stack(asset_list, data.table = TRUE)
asset_dt[, net_profit := closed_profit + pos_profit - fee]
asset_dt[, profit := c(0,diff(net_profit))]
###########################Performance##########################################
# 计算每日收益率：（不加杠杆，return = 每日利润/本金）
asset_dt[, return := profit / (shadow_account)]
calc_annual_return <- function(x){ # 根据日度收益率计算年化收益率
(1 + sum(x)) ^(250 / length(x)) - 1   #由于本金永远锁定在Account而非再投资，这里不能用prod而是用sum来简单加总
}
calc_sharpe_ratio <- function(x){ # 根据日度收益率计算 sharpe ratio
calc_annual_return(x) / (sqrt(250) * sd(x))
}
# 年化收益率
annual_return <- calc_annual_return(asset_dt$return)
# 夏普比
sharpe_ratio <- calc_sharpe_ratio(asset_dt$return)
# 最大回撤
asset_dt[, cum_profit := cumsum(profit)]
asset_dt[, cummax_cum_profit := cummax(cum_profit)]
asset_dt[, drawdown := cum_profit - cummax_cum_profit]
maxdrawdown <- min(asset_dt$drawdown)
maxdrawdown_idx <- which.min(asset_dt$drawdown)
maxdrawdown_per <-
asset_dt[maxdrawdown_idx, drawdown] /
asset_dt[maxdrawdown_idx, cummax_cum_profit]
# 胜率
win_prob <- mean(trades_dt$profit > 0)
# 平均盈亏比
win_loss_ratio <-
(sum(trades_dt[profit > 0, profit]) / trades_dt[profit > 0, .N]) /
(sum(trades_dt[profit <= 0, -profit]) / trades_dt[profit <= 0, .N])
indicators <- sprintf("
年化收益率：%s
Sharpe_Ratio: %f
最大资金回撤：%f（百分比：%s）
胜率：%s
平均盈亏比：%f
",
scales::percent(annual_return),
sharpe_ratio,
maxdrawdown, scales::percent(maxdrawdown_per),
scales::percent(win_prob),
win_loss_ratio
)
cat(indicators)
# 找出利润最大的一次交易
trades_dt[which.max(trades_dt$profit), .(enter_date, leave_date)]
# 资金曲线
plot(asset_dt$net_profit, type = "l")
hist(trades_dt$profit, breaks = 50)
par(mfrow = c(3, 1))
plot(asset_dt$net_profit, type = "l", main = "account") # 账户资金曲线
plot(asset_dt$return, type = "h", main = "daily return") # 日度收益率
plot(asset_dt$pos_dir, type = "h", main = "position") # 每日postion
par(mfrow = c(1,1))
} #end of if (nrow(data[[i]]) < 56)
test_4
holding
units
NxDPPs
shadow_account
units
